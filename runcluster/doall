#!/bin/bash

usage() {
  echo "Usage: $0 (start | stop) [ svc_name ... ] [-options]"
  echo "  Starts or stops a set of LOCKSS services, either those named on the"
  echo "  command line or the entire set defined in config/services.xxx"
  echo "Options:"
  echo "  -svcs <file> Use alternate services file (default config/services.snapshot,"
  echo "               which runs SNAPSHOT artifacts downloaded from maven central)"
  echo "  -local       Synonym for -svcs config/services.local (which runs"
  echo "               locally built service jars)"
  echo "  -pg          Use external PostgreSQL database (default)"
  echo "  -derby       Use embedded Derby database"
  echo "  -p lockss:<name>  Load PLN config from http://props.lockss.org:8001/<name>/lockss.xml"
  echo "  -p <url>     Load PLN config from prop server <url>"
  echo "  -p <file>    Load PLN config from <file> (default config/lockss.xml)"
  echo "  -cluster <file>  Load cluster config from <file> (default config/cluster.xml)"
  echo "  -c <file>    Load additional config from <file> (incl tdb .xml)"
  echo "  -x <dir>     Load config from dir/*.xml (typically used for tdb files)"
  echo "  -g <group>   Set polling group to <group>"
  echo "  -a <app_arg> Add <app_arg> to command line"
  echo "  -r <credentials_file> Load Rest client credentials from file"
  echo "  -Dprop=val   Set System property"
  echo "  -jar <file>  Add jar <file> to the classpath"
  echo "  -U           Force maven to check for updated artifacts"
  echo "  -force       Use with \"stop\" to force hung JVMs to exit"
}

shopt -s nullglob

verb="$1"
shift

case "$verb" in
  start | stop ) ;;
  * )
    echo "first arg must be start or stop"
    exit 1
esac

# dirs
logdir=logs
piddir=pids
libdir=tmplib

mkdir -p "${logdir}" "${piddir}" "${libdir}" ./data

l4j_xml=config/log4j2-runcluster.xml

# defaults
svcs_file="./config/services.snapshot"
svcs_file_local="./config/services.local"
forcekill=
mvn_U=
db_props=config/derby.xml

declare -A svc_map		# maps svc_name -> jar or artifact
svc_list=()			# ordered array of svc_name

cp_jars=lib			# jars to put on classpath.  "lib" is
				# required for uber jar
pln_props="config/lockss.xml"
cluster_props="config/cluster.xml config/cluster.opt"
other_props=
java_args="-Djava.util.logging.manager=org.apache.logging.log4j.jul.LogManager -Dorg.springframework.boot.logging.LoggingSystem=none"

### Functions ###

# preface_each space_separated_string prefix
preface_each() {
  local words=`trim "$1"`
  if [ -z "$words" ]; then
      return
  fi
  echo `echo " " $words | sed 's/  */ '"$2"' /g'`
}

# trim leading and trailing blanks
trim() {
  echo `echo $1 | sed -e 's/^ *//' -e 's/ *$//'`
}

# return absolute path of $1
abspath() {                                               
  ( cd "$(dirname "$1")"
    printf "%s/%s\n" "$(pwd)" "$(basename "$1")" )
}

# load svc_map and svc_list from services file
read_services() {
  while IFS='=' read name path; do
    if [ -n "${name}" ]; then
	svc_map[${name}]=${path}
	svc_list+=( ${name} )
    fi
  done < "$1"
}


# Write service uber jar to temp dir, return (echo) jar name in temp dir
# copy_jar svc_name jar-file   or
# copy_jar svc_name mvn:groupid:artifactid:version
copy_jar() {
  case "$2" in
    "" )
      echo "No service definition found for $1" >&2
      return
      ;;
    mvn:* )
      # mvn:artifact - strip "mvn:"
      local art=${2#mvn:}
      # append :jar:with-deps if necessary
      case "${art}" in
	*:jar:with-deps ) ;;
	* ) art="${art}:jar:with-deps" ;;
      esac
      # select appropriate maven repo
      case "${art}" in
	*SNAPSHOT* )
	  mvn_repo="https://oss.sonatype.org/content/repositories/snapshots"
	  ;;
	* )
	  mvn_repo="https://mvnrepository.com/artifact/"
	  ;;
      esac
      # fetch jar to libdir
      echo "Fetching ${art}" >&2
      mvn ${mvn_U} -B dependency:copy \
	  -DrepoUrl=${mvn_repo} \
	  -Dartifact=${art} \
	  -DoutputDirectory="${libdir}" \
	  -Dmdep.useBaseVersion \
	  -Dtransitive=false >>logs/maven.log
      if [ $? -ne 0 ]; then
	  echo "Couldn't fetch ${art}, skipping it" >&2
	  return
      fi
      # construct jar file name from artifact and return it
      local jar=`echo "${art}" | sed -E 's/[^:]+:([^:]+):([^:]+):?.*/\1-\2-with-deps.jar/'`
      echo "${libdir}/${jar}"
      ;;
    * )
      # copy jar to libdir, return name
      local jar="${libdir}/${svc_name}.jar"
      cp -u "${jar_file}" "${jar}"
      echo "${jar}"
      ;;
  esac
}

# start a service
# start_service <name> <jar-file>
start_service() {
  local svc_name="$1"
  local name_arg="--${svc_name}--"
  local cfgsvc_args="-c http://lockss-u:lockss-p@localhost:24620 -l http://localhost:24620/config/file/cluster"
  local local_props_args=
  local bootstrap_args="-b resource:application.properties -b config/bootstrap.xml"
  local extra_args=
  local jar_file="${svc_map[${svc_name}]}"

  local pid_file="${piddir}/${svc_name}.pid"
  if [ -f "${pid_file}" ]; then
      echo "${svc_name} already running"
      return 1
  fi
  case "${svc_name}" in
    cfg )
      # cfgsvc loads main config files, does not load from cfgsvc
      local_props_args=`preface_each "${pln_props} ${cluster_props} ${db_props}" -l`
#      local_props_args="-l ${pln_props} -l ${cluster_props}"
      cfgsvc_args=
      ;;
    repo )
      # repo gets spring config file with repo type & location
      mkdir -p ./data/repo
      local repo_data=`abspath ./data/repo`
      touch config/repo.properties
      local repo_config=`abspath config/repo.properties`
      echo "repo.spec=local:${repo_data}" > ${repo_config}
      echo "repo.persistIndexName=localindex.ser" >> ${repo_config}
      extra_args="--spring.config.location=file:${repo_config}"
      ;;
    * )
      : ;;
  esac

  local std_file="${logdir}/${svc_name}.std"
  local tmp_jar=`copy_jar "${svc_name}" "${jar_file}"`
  if [ -n "${tmp_jar}" ]; then
      echo "Starting ${svc_name}"
      ( env REPO_MAX_WARC_SIZE=100000000 \
            LOG4J_LOCKSS_CONFIG="${l4j_xml}" \
            LOCKSS_LOG_DIR="${logdir}" \
            LOCKSS_SERVICE_NAME="${svc_name}" \
	    java ${java_args} "-Dloader.path=${cp_jars}" -jar ${tmp_jar} ${name_arg} ${bootstrap_args} ${cfgsvc_args} ${local_props_args} ${other_args} ${extra_args} > ${std_file} 2>&1 &
	pid=$!
	if [ -n "${pid_file}" ]; then
	    echo ${pid} > ${pid_file}
	fi
	wait ${pid}
	status=$?
	if [ -n "${pid_file}" ]; then
	    rm -f ${pid_file}
	fi
	echo "${svc_name} stopped with status ${status} at `date`" >&2
	exit 0 ) &
  fi
}

# stop a service
stop_service() {
  local svc_name="$1"
  local pid_file="${piddir}/${svc_name}.pid"
  if [ -f ${pid_file} ] ; then
      local pid="`cat ${pid_file}`"
      if [ -n "${pid}" ] ; then
	  if kill -s 0 "${pid}" ; then
	      echo "stopping ${svc_name}"
	      kill $forcekill `cat ${pid_file}`
	  else
	    echo "${svc_name} not running, deleting stale pid file"
	    rm -f "${pid_file}"
	  fi
      else
	echo "${svc_name} not running, deleting empty pid file"
	rm -f "${pid_file}"
      fi
  else
    echo "${svc_name} not running"
  fi
}

cleanup() {
  /bin/rm -f $temp_svcs_file
}

### Main ###

# process service name args, if any
svc_names=
while [ -n "$1" ]; do
  case "$1" in
    -* ) break ;;
    * ) svc_names="${svc_names} $1"
	shift; continue ;;
  esac
done

while [ -n "$1" ]; do
  case "$1" in
    "-svcs" )
      svcs_file="$2"
      shift; shift; continue ;;
    "-local" )
      svcs_file="${svcs_file_local}"
      shift; continue ;;
    "-p" )
      pln_props="$2"
      shift; shift; continue ;;
    -cluster )
      cluster_props="$2"
      shift; shift; continue ;;
    -pg | -postgres )
      db_props=config/postgres.xml
      shift; continue ;;
    -derby )
      db_props=config/derby.xml
      shift; continue ;;
    -jar )
      # copy jar to tmplib
      tmptmpjar="${libdir}/`basename $2`"
      cp -u "$2" "${tmptmpjar}"
      cp_jars="${cp_jars},${tmptmpjar}"
      shift; shift; continue ;;
    -D* )
      java_args="${java_args} $1"
      shift; continue ;;
    -force )
      forcekill="-9"
      shift; continue ;;
    -U )
      mvn_U="-U"
      shift; continue ;;
    -a | -g | -r | -x )
      other_args="$other_args $1 $2"
      shift; shift; continue ;;
    -c )
      other_args="$other_args -l $2"
      shift; shift; continue ;;
    -h )
      usage
      exit 0 ;;
    -* )
      other_args="$other_args $1"
      shift; continue ;;
    * )
      echo "Unknown option: $1"
      exit 1 ;;
  esac
  break;
done

case "$verb" in
  "clean" )
    echo "clean not yet implemented"
    exit 1 ;;
  "start" )
    if [ -z "${pln_props}" ]; then
	echo "-p is required"
	exit 1
    fi ;;
esac

temp_svcs_file=$(mktemp runcluster.XXXXX)

# Clean up if script is interrupted or terminated.
trap "cleanup" SIGINT SIGTERM 1 0


sed '/^[[:blank:]]*#/d;s/#.*//' "$svcs_file" > ${temp_svcs_file}
read_services ${temp_svcs_file}

if [ -n "${svc_names}" ]; then
    # use explicit list of services
    svc_list=()
    for name in ${svc_names}; do
      svc_list+=( ${name} )
    done
else
  case "$verb" in
    "start" )
      # use list from services file (svc_list already set by read_services)
      ;;
    "stop" )
      # use list of running services (pids/*.pid)
      svc_list=()
      for pidfile in ${piddir}/*.pid; do
	svc_list+=( $(basename -s .pid "$pidfile") )
      done
      ;;
  esac
fi

#  set -x

for name in ${svc_list[@]}; do
  case "$verb" in
    "start" )
      start_service "${name}"
      continue ;;
    "stop" )
      stop_service "$name"
      continue ;;
  esac
done
