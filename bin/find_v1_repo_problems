#!/usr/bin/env python3

# Examine one or more AUs for URLs that the V1 repository doesn't represent
# correctly.  It does this by comparing the URL generated by the
# repository's iterator with the X-Lockss-node-url property, which recorded
# the original URL supplied to the repository.  These differences are
# detected:
# - dropped final slash
# - encoding differences (repo performs minimal encoding necessary for
#   filesystem)
# - inconsistencies between versions (e.g, if both slash and non-slash
#   variants were collected for the same URL

import sys
import argparse
import logging
import requests
import urllib.parse

# fetch an item list from ListObjects
def get_list(argdict):

    # prevent ListObjects from returning html error pages
    argdict['errorResp'] = 'text'

    url = url_pat % urllib.parse.urlencode(argdict)
    resp = requests.get(url, stream=True,
                        auth=requests.auth.HTTPBasicAuth(user, passwd))
    # throw if non-200 status
    resp.raise_for_status()
    if resp.encoding is None:
        resp.encoding = 'utf-8'

    # return non-comment lines
    return [line for line in resp.iter_lines(decode_unicode=True)
            if line and not str.startswith(line, '#')]
    

# return list of (auid, auname) tuples 
def find_auids():
    lines = get_list({'type': 'aus',
                      'fields': 'Auid,AuName'})
    return [ line.split('\t') for line in lines ]


def printifnz(cnt, msg):
    if args.verbose or cnt != 0:
        print(msg)


parser = argparse.ArgumentParser(description='Find CUs with V1 repository specific (incorrect) names.')
parser.add_argument('hostport', help='HOST:PORT')
parser.add_argument('-u', '--userpass', metavar='USER:PASS', required=True)
parser.add_argument('--auid', nargs='*',
                    help='one or more (non-urlencoded) AUIDs. If none supplied, all active AUs will be searched')
parser.add_argument('-mv', '--maxversions', type=int, default=0,
                    help='Optionally limit number of versions of each URL examined for inter-version discrepencies. Default is no limit.')
parser.add_argument('-/', '--noslash', action='store_true', help='Count but do not display URLs missing only final slash')
parser.add_argument('-v', '--verbose', action='store_true', help='Log totals for AUs that have no discrepancies')

args = parser.parse_args()
#print(args)

url_pat = 'http://%s/ListObjects?%%s' % args.hostport

user, ignore, passwd = str.partition(args.userpass, ':')

if args.auid:
    # if auids in args, turn into list of (auid, None) tuples
    auids = [ (x, None) for x in args.auid ]
else:
    # else get list from daemon
    try:
        auids = find_auids()
    except Exception as e:
        logging.error('Couldn\'t retrieve AUID list: %s' % e)
        sys.exit(1)
        
if not auids:
    print('# No AUIDs found')
    sys.exit(1)


for (auid, auname) in auids:
    try:
        lines = get_list({'type': 'urls',
                          'auid': auid,
                          'fields': 'PropsUrl,Version',
                          'maxversions': args.maxversions})
        msgs = []
        numslash=0
        numother=0
        numalts=0
        alts = set()            # accumulates variants of single url

        prevurl = None
        for line in lines:
#            print(line)
            url, realUrl, ver = line.split()

            if url != prevurl:
                # if prev url had more than one variant, record it
                if len(alts) > 1:
                    msgs.append('VARIANTS:\t%s\t%s' % (prevurl, alts))
                    numalts += 1

                prevurl = url
                alts = set()
            alts.add(realUrl)

            if url != realUrl:
                if realUrl.endswith('/') and url == realUrl[0:-1]:
                    # missing trailing slash
                    numslash += 1
                    if not args.noslash:
                        msgs.append('SLASH:\t%s\t%s' % (url, realUrl))
                else:
                    # other difference - encoding?
                    numother += 1
                    msgs.append('OTHER:\t%s\t%s' % (url, realUrl))

        # if final url had more than one variant, record it
        if len(alts) > 1:
            msgs.append('VARIANTS:\t%s\t%s' % (url, alts))
            numalts += 1

        if args.verbose or msgs or numalts > 1 or not (numslash == numother == 0):
            print('\nAUID: %s' % auid)
            if auname:
                print('AUNAME: %s' % auname)
            for line in msgs:
                print(line)

        printifnz(numslash, 'TOTAL SLASH: %d' % numslash)
        printifnz(numother, 'TOTAL OTHER: %d' % numother)
        printifnz(numalts, 'TOTAL VARIANTS: %d' % numalts)

    except requests.exceptions.HTTPError:
        print('ERROR: AUID not found: %s' % auid)

